### 1、什么是算法？

算法就是计算或者解决问题的步骤。我们可以把它想象成食谱。要想做出特定的料理，就要遵循食谱上的步骤；同理，要想用计算机解决特定的问题，就要遵循算法。这里所说的特定问题多种多样，比如“将随意排列的数字按从小到大的顺序重新排列”“寻找出发点到目的地的最短路径”，等等。食谱和算法之间最大的区别就在于算法是严密的。食谱上经常会有描述得比较模糊的部分，而算法的步骤都是用数学方式来描述的，所以十分明确。算法和程序有些相似，区别在于程序是以计算机能够理解的编程语言编写而成的，可以在计算机上运行，而算法是以人类能够理解的方式描述的，用于编写程序之前。不过，在这个过程中到哪里为止是算法、从哪里开始是程序，并没有明确的界限。就算使用同一个算法，编程语言不同，写出来的程序也不同；即便使用相同的编程语言，写程序的人不同，那么写出来的程序也是不同的。

摘录自《我的第一本算法》，这本书特别适合新手学习，以图形的方式来讲解，易于理解。

### 2、数据结构

什么是数据结构？

答：数据存储于内存中，决定了数据顺序和位置关系的便是“数据结构”。

1. 数组（Array）

数据按顺序存储在内存的连续空间内。

2. 链表（Linked List）

是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

3. 栈（Stack）

栈也是一种数据呈线性排列的数据结构，遵循后进先出原则

4. 队列（Queue）

普通队列：队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

双端队列（Deque）：入口和出口都可以入队和出队

优先队列（PriorityQueue）：根据优先级出队

5. 哈希表（Hash table）

哈希表（Hash table），也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。

6. 树（Tree）

一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

特点：

* 每个节点都只有有限个子节点或无子节点
* 没有父节点的节点称为根节点
* 每一个非根节点有且仅有一个父节点
* 除了根节点外，每个子节点可以分为多个不相交的子树
* 树中没有环路
7. 堆（Heap）

可以迅速找到一堆数中的最大或者最小值的数据结构。将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。常见的堆有二叉堆、斐波那契堆等。

满足下列性质：

* 堆中任意节点的值总是>=或<=其子节点的值
* 堆总是一颗完全二叉树
8. 图（Graph）

图结构也是一种非线性数据结构，并且每个数据元素之间可以任意关联。

一个典型的图结构包括如下两个部分：

* 顶点（Vertex）：图中的数据元素
* 边（Edge）：图中连接这些顶点的线

存储方法：邻接矩阵、邻接表

![图片](https://uploader.shimo.im/f/0EWVCDjlTBmw1Ga5.png!thumbnail?fileGuid=jVD8jjdtYgqcrRHV)

邻接矩阵

![图片](https://uploader.shimo.im/f/naE9X4fnVq7GtK9w.png!thumbnail?fileGuid=jVD8jjdtYgqcrRHV)

邻接表

关于数据结构总结脑图附件

[数据结构和算法-思维导图.pdf](https://uploader.shimo.im/f/VNXXts3PE3uAMFMr.pdf?fileGuid=jVD8jjdtYgqcrRHV)

### 3、算法

1. 递归（Recursion）

递归也是一种循环，不过是通过函数体自己调用自己来进行的循环

简单示例：计算 n！

```python
// n！= 1*2*3*...*n
def Factorial(n):
  if n<=1:
    return 1
  return n*Factorial(n-1) 
```
代码模板（Java）
```java
public void recur(int level , int param){
  // terminator
  if (level > MAX_LEVEL){
    // process result
    retutn;
  }
  // process current logic
  process(level,param);
  // drill down
  recur(level+1,newParam);
  // restore current status
}
```
* [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)（阿里巴巴、腾讯、字节跳动在半年内面试常考）

常规写法：

```java
public int climbStairs(int n) {
    if(n <= 2){
        return n;
    }
    return climbStairs(n-1) + climbStairs(n-2);
}
```
升级版本：
```java
public int climbStairs(int n) {
    int f1 = 1, f2 = 2, f3 = 0;
    for (int i = 3; i <= n; i++) {
        f3 = f1 + f2;
        f1 = f2;
        f2 = f3;
    }
    return f3;
}
```
* [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)(字节跳动在半年内面试中考过)
```java
public List<String> generateParenthesis(int n) {
    List<String> res = new ArrayList<>();
    if (n < 1) {
        return res;
    }
    generate(0, 0, "", res, n);
    return res;
}
public void generate(int left, int right, String s, List<String> res, int n) {
    // 1.递归终结条件
    if (left == n && right == n) {
        res.add(s);
        return;
    }
    // 2.处理当前层
    // 右括号多余左括号，说明已经是无效括号组合
    if (left < right) {
        return;
    }
    // 3.下探下一层
    // 如果左括号还能添加,右括号不变
    if (left < n)
        generate(left + 1, right, s + "(", res, n);
    // 如果右括号还能添加，左括号不变
    if (right < n)
        generate(left, right + 1, s + ")", res, n);
}
```
* [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)(谷歌、字节跳动、Facebook 在半年内面试中考过)
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null)
        return null;
    TreeNode left = root.left;
    root.left = root.right;
    root.right = left;
    invertTree(root.left);
    invertTree(root.right);
    return root;
}
```
* [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree)（亚马逊、微软、Facebook 在半年内面试中考过）
```java
// 中序遍历访问，先遍历左子树，如果有当前节点值<=前节点值，不满足条件
private TreeNode per;
public boolean isValidBST(TreeNode root) {
    if (root == null)
        return true;
    if (!isValidBST(root.left)) return false;
    if (per != null && root.val <= per.val) return false;
    per = root;
    if (!isValidBST(root.right)) return false;
    return true;
}
```
* [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)（亚马逊、微软、字节跳动在半年内面试中考过）
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
```
* [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)（Facebook、字节跳动、谷歌在半年内面试中考过）
```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        if(root.left == null && root.right ==null) return 1;
        if(root.left == null || root.right == null)
        return minDepth(root.left) + minDepth(root.right) + 1;
        return Math.min(minDepth(root.left),minDepth(root.right)) + 1;
    }
}
```
* [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)（Facebook、亚马逊在半年内面试常考）
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder str = new StringBuilder();
        // BFS
        return traversTree(root,str);
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.isEmpty() || data.equals("#")){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList();
        String[] nodes = data.split(",");
        TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));
        queue.add(root);
        for(int i = 1; i < nodes.length ; i++){
            TreeNode p = queue.poll();
            if(!"#".equals(nodes[i])){
                TreeNode left = new TreeNode(Integer.valueOf(nodes[i]));
                p.left = left;
                queue.add(left);
            }
            if(!"#".equals(nodes[++i])){
                TreeNode right = new TreeNode(Integer.valueOf(nodes[i]));
                p.right = right;
                queue.add(right);
            }
        }
        return root;
    }
    public String traversTree(TreeNode root,StringBuilder str){
        if(root == null) {
            return "#";
        }
        Queue<TreeNode> queue = new LinkedList();
        queue.add(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node == null){
                str.append("#"+",");
                continue;
            }
            str.append(node.val+",");
            queue.add(node.left);
            queue.add(node.right);
        }
        return str.toString();
    }
}
// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```
课后作业：
* [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)（Facebook 在半年内面试常考）
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```
* [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)（字节跳动、亚马逊、微软在半年内面试中考过）
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private Map<Integer, Integer> indexMap = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length == 0 || inorder.length == 0) {
            return null;
        }
        int n = preorder.length;
        // 将中序遍历的数组保存在map中，以便快速查询节点对应的下标
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return buildTreeHelper(preorder, inorder, 0, n - 1, 0, n - 1);
    }
    private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preLeft, int preRight, int inLeft, int inRight) {
        // 递归结束条件，数组切分完为止
        if (preLeft > preRight) {
            return null;
        }
        // 前序遍历的第一个节点就是根节点
        int perRoot = preLeft;
        // 查询根节点在中序遍历中的下标位置
        int index_root = (int)indexMap.get(preorder[perRoot]);
        // 创建根节点
        TreeNode root = new TreeNode(preorder[perRoot]);
        // 计算左子树中的节点数目，以index_root下标为中心将前序遍历数组inorder切分为左子树、右子树两部分
        int left_size = index_root - inLeft;
        // 递归构造左子树
        root.left = buildTreeHelper(preorder, inorder, preLeft + 1, preLeft + left_size, inLeft, index_root - 1);
        // 递归构造右子树
        root.right = buildTreeHelper(preorder, inorder, preLeft + left_size + 1, preRight, index_root + 1, inRight);
        return root;
    }
}
```
* [组合](https://leetcode-cn.com/problems/combinations/)（微软、亚马逊、谷歌在半年内面试中考过）
```java
class Solution {
     public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        dfs(n, k, 1, new ArrayList<Integer>(), res);
        return res;
    }
    private void dfs(int n, int k, int start, ArrayList<Integer> list, List<List<Integer>> res) {
        if (k == 0) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i <= n - k + 1; i++) {
            list.add(i);
            dfs9(n, k - 1, i + 1, list, res);
            list.remove(list.size() - 1);
        }
    }
}
```
* [全排列](https://leetcode-cn.com/problems/permutations/)（字节跳动在半年内面试常考）
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();
        boolean[] used = new boolean[nums.length];
        dfs(nums, 0, path, used, res);
        return res;
    }
    private void dfs(int[] nums, int level, Deque<Integer> path, boolean[] used, List<List<Integer>> res) {
        if (level == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int j = 0; j < nums.length; j++) {
            if (!used[j]) {
                path.addLast(nums[j]);
                used[j] = true;
                dfs(nums, level + 1, path, used, res);
                used[j] = false;
                path.removeLast();
            }
        }
    }
}
```
* [全排列 II ](https://leetcode-cn.com/problems/permutations-ii/)（亚马逊、字节跳动、Facebook 在半年内面试中考过）
```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();
        boolean[] used = new boolean[nums.length];
        // 排序（升序或者降序都可以），排序是剪枝的前提
        Arrays.sort(nums);
        dfs(nums, 0, path, used, res);
        return res;
    }
    private void dfs(int[] nums, int level, Deque<Integer> path, boolean[] used, List<List<Integer>> res) {
        if (level == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int j = 0; j < nums.length; j++) {
            if (used[j]) {
                continue;
            }
            // 剪枝，取掉重复的搜索结果
            if (j > 0 && nums[j] == nums[j - 1] && !used[j - 1]) {
                continue;
            }
            path.addLast(nums[j]);
            used[j] = true;
            dfs(nums, level + 1, path, used, res);
            used[j] = false;
            path.removeLast();
        }
    }
}
```
2. 分治、回溯
* 分治代码模板
```java
private static int divide_conquer(Problem problem, ) {
  if (problem == NULL) {
    int res = process_last_result();
    return res;
  }
  subProblems = split_problem(problem)
  res0 = divide_conquer(subProblems[0])
  res1 = divide_conquer(subProblems[1])
  result = process_result(res0, res1);
  return result;
}
```
* [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)
```java
class Solution {
    public double myPow(double x, int n) {
        if(n == 0) return 1;
        if(n == 1) return x;
        if(n == -1) return 1/x;
        double helf = myPow(x,n/2);
        double rest = myPow(x,n%2);
        return rest*helf*helf;
    }
}
```
* [78. 子集](https://leetcode-cn.com/problems/subsets/)
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        subsets(nums,0,new ArrayList(),result);
        return result;
    }
    public void subsets(int[] nums,int index ,List<Integer> list,List<List<Integer>> result){
        result.add(new ArrayList<>(list));
        for(int i = index;i<nums.length;i++){
            list.add(nums[i]);
            subsets(nums,i + 1,list,result);
            list.remove(list.size() - 1);
        }
    }
}
```
* [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

思路：排序

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```
思路：摩尔投票法
相同的元素则 票数+1，遇到不同的则 票数-1

因为“多数元素”个数 > n/2 ，则其余元素个数 <= n/2

这样“多数元素”的票数就能抵消掉所有其余元素的票数，最终剩余的就是票数最多的元素。

```java
class Solution {
    public int majorityElement(int[] nums) {
        // 默认选中第一个元素为候选人，票数默认10
        int count = 1;
        int choose = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == choose) {
                count++;
            } else {
                count--;
            }
            // 当票数为0时，需要更换候选人，票数也重置为1 ，开始重新投票
            if (count == 0) {
                choose = nums[i];
                count = 1;
            }
        }
        return choose;
    }
}
```
* [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

思路：dfs+回溯

![图片](https://uploader.shimo.im/f/ooqRWHZQ6AFwllN7.png!thumbnail?fileGuid=jVD8jjdtYgqcrRHV)

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList();
        if (digits.length() == 0) return res;
        Map<Character, String> keyboard = new HashMap<>();
        keyboard.put('2', "abc");
        keyboard.put('3', "def");
        keyboard.put('4', "ghi");
        keyboard.put('5', "jkl");
        keyboard.put('6', "mno");
        keyboard.put('7', "pqrs");
        keyboard.put('8', "tuv");
        keyboard.put('9', "wxyz");
        search(digits, 0, "", res, keyboard);
        return res;
    }
    public void search(String digits, int level, String s, List<String> res, Map<Character, String> keyboard) {
        if (level == digits.length()) {
            res.add(s);
            return;
        }
        String letter = keyboard.get(digits.charAt(level));
        for (int i = 0; i < letter.length(); i++) {
            search(digits, level + 1, s + letter.charAt(i), res, keyboard);
        }
    }
}
```
* [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)
```plain
```
3. 深度优先搜索、广度优先搜索
* DFS代码模板

中序遍历

```java
//Java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if(root==null){
        return allResults;
    }
    travel(root,0,allResults);
    return allResults;
}
public void travel(TreeNode root,int level,List<List<Integer>> results){
    if(results.size()==level){
        results.add(new ArrayList<>());
    }
    results.get(level).add(root.val);
    if(root.left!=null){
        travel(root.left,level+1,results);
    }
    if(root.right!=null){
        travel(root.right,level+1,results);
    }
}
```
* BFS代码模板

层序遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if (root == null) {
        return allResults;
    }
    Queue<TreeNode> nodes = new LinkedList<>();
    nodes.add(root);
    while (!nodes.isEmpty()) {
        int size = nodes.size();
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = nodes.poll();
            results.add(node.val);
            if (node.left != null) {
                nodes.add(node.left);
            }
            if (node.right != null) {
                nodes.add(node.right);
            }
        }
        allResults.add(results);
    }
    return allResults;
}
```
* [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0 ; i < size; i++){
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(list);
        }
        return res;
    }
}
```
* [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            int max = Integer.MIN_VALUE;
            for(int i = 0;i < size;i++){
                TreeNode node = queue.poll();
                max = Math.max(max,node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(max);
        }
        return res;
    }
}
```
* [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;
    public Node() {}
    public Node(int _val) {
        val = _val;
    }
    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        traverse(root,res);
        return res;
    }
    private void traverse(Node node,List<Integer> res){
        if(node == null){
            return;
        }
        res.add(node.val);
        List<Node> children = node.children;
        for(int i = 0 ; i < children.size(); i++){
            traverse(children.get(i),res);
        }
    }
}
```
* [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)
```java
class Solution {
    public int numIslands(char[][] grid) {
        if(grid.length == 0 && grid[0].length == 0) return 0;
        int count = 0;
        for(int i = 0 ; i < grid.length; i++){
            for(int j = 0; j < grid[i].length;j++){
                if(grid[i][j] == '1'){
                    count++;
                    dfs(grid,i,j);
                }
            }
        }
        return count;
    }
    private void dfs(char[][] grid , int i , int j){
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0'){
            return;
        }
        grid[i][j] = '0';
        dfs(grid,i+1,j);// rigth
        dfs(grid,i-1,j);// left
        dfs(grid,i,j+1);// top
        dfs(grid,i,j-1);// bottom
    }
}
```
* [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)
```plain
```
4. 贪心算法

贪心算法是一种在每一步选择中都采取在当下状态下最好或最优（最有利）的选择，从而希望导致结果是全局最好或最优的算法。

关于贪心算法推荐博客[贪心算法](https://mp.weixin.qq.com/s/O935TaoHE9Eexwe_vSbRAg)

适用场景：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

贪心策略：每次兑换都从最大的零钱开始兑换，找最少硬币兑换个数，直至兑换完毕。

```java
class Solution {
    private int res = Integer.MAX_VALUE;
    public int coinChange(int[] coins, int amount) {
        if(amount == 0) return 0;
        Arrays.sort(coins);
        change(coins,amount,coins.length - 1,0);
        return res == Integer.MAX_VALUE ? -1 : res;
    }
    public void change(int[] coins, int amount , int coinIndex ,int count){
        if(amount == 0){
            res = Math.min(res,count);
            return;
        }
        if(coinIndex < 0) return;
        for(int k = amount/coins[coinIndex];k>=0 && k + count< res ; k--){
            change(coins,amount-(k*coins[coinIndex]),coinIndex - 1,count + k);
        }
    }
}
```
* [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

贪心策略：低买高卖，所有上涨日都买卖，下跌日都不进行买卖，这样的收益是最大的

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            int temp = prices[i] - prices[i - 1];
            if (temp > 0) {
                profit += temp;
            }
        }
        return profit;
    }
}
```
5. 二分查找
* [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0,right = nums.length - 1,mid = 0;
        while(left <= right){
            mid = left + (right - left)/2;
            if(target == nums[mid]) return mid;
            if(nums[left] <= nums[mid]){
                if(target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                }else {
                    left = mid + 1;
                }
            }else {
                if(target > nums[mid] && target <= nums[right]){
                    left = mid + 1;
                }else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }       
}
```
* [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)
```java
class Solution {
    public int mySqrt(int x) {
        if (x == 0) {
            return x;
        }
        long left = 1, right = x/2, mid = 1;
        while(left < right){
            mid = (left + right + 1) >>> 1;
            if(mid*mid > x){
                right = mid - 1;
            }else{
                left = mid;
            }
        }
        return (int)left;
    }
}
```
* [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

思路：二分法

将二维数组转换为虚拟一维数组，长度= m*n，每次找中间值 matrix[mid / n][mid % n] 与 target 对比；

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0) return false;
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0, right = m * n - 1;
        int mid = 0, num = 0;
        while (left <= right) {
            mid = left + (right - left) / 2;
            num = matrix[mid / n][mid % n];
            if (target == num) {
                return true;
            }
            if (target > num) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
}
```
6. 动态规划

关键点：动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）

共性：都是找到重复子问题

差异性：最优子结构、中途可以淘汰次优解

经典案例：[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

* 1）、常规递归法：
```java
class Solution {
    public int fib(int n) {
        return n <= 1 ? n : fib(n-1) + fib(n-2);
    }
}
```
* 2）、保存中间值递归法：
```java
class Solution {
    private int[] num;
    public int fib(int n) {
        num = new int[n+1];
        return fibonacci(n);
    }
    public int fibonacci(int n){
        if(n <= 1) return n;
        if(num[n] == 0){
            num[n] = fibonacci(n-1) + fibonacci(n-2);
            num[n] %= 1000000007;
        }
        return num[n];
    }
}
```
* 3）、自底向上递推
```java
class Solution {
    public int fib(int n) {
        if(n <= 1) return n;
        int[] num = new int[n+1];
        num[0] = 0;
        num[1] = 1;
        for(int i = 2; i <= n; i++){
            num[i] = num[i-1] + num[i-2];
            num[i] %= 1000000007;
        }
        return num[n];
    }
}
```
* 4）、动态规划
```java
class Solution {
    public int fib(int n) {
        if(n <= 1) return n;
        int f0 = 0,f1 = 1,f2 = 0;
        for(int i = 2; i <= n; i++){
            f2 = (f0 + f1) %1000000007;
            f0 = f1;
            f1 = f2;
        }
        return f2;
    }
}
```
* [6](https://leetcode-cn.com/problems/unique-paths/)[2](https://leetcode-cn.com/problems/unique-paths/)[. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

![图片](https://uploader.shimo.im/f/sYmsMgz8T20nxbon.png!thumbnail?fileGuid=jVD8jjdtYgqcrRHV)

思路：使用二维数组表示机器人行走区域，（0，0）表示起点start，dp[i][j]表示机器人行走到（i，j）坐标的路径条数，那么最终答案就是求机器人行走至终点（m-1,n-1）对应的dp[m-1][n-1]的值；已知机器人只能向下或向右行走，那么当机器人行走至第一行或第一列任意位置的路径条数都为 1，也就是dp[0][j] == 1，dp[i][0] == 1；同样也可推导出机器人行走至（i，j）位置只能从（i-1，j）点或（i，j-1）点走过来，那么dp[i][j] == dp[i-1][j] + dp[i][j-1];

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m == 0 || n == 0) return 0;
        int[][] dp = new int[m][n];
        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int j = 0; j < n; j++) dp[0][j] = 1;
        for(int i = 1; i < m;i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```
优化版：
```java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m == 0 || n == 0) return 0;
        int[][] dp = new int[m][n];
        for(int i = 0; i < m;i++){
            for(int j = 0; j < n; j++){
                if (i == 0 || j == 0){
                    dp[i][j] = 1;
                }else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```
* 进阶：[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

思路：不同于62题，机器人在行走过程中会碰到障碍物阻挡。同样的思路我们只需要处理无障碍物的情况；

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length , n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        for(int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for(int i = 1; i < m;i++){
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i][j] == 0)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```
内存优化版：
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length , n = obstacleGrid[0].length;
        int[] dp = new int[n+1];
        dp[1] = 1;
        for(int i = 0; i < m;i++){
            for(int j = 1; j <= n; j++){
                if(obstacleGrid[i][j-1] == 1)
                    dp[j] = 0;
                else
                    dp[j] += dp[j-1];
            }
        }
        return dp[n];
    }
}
```
* 高阶：[980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)
```java
class Solution {
    private int res = 0;
    public int uniquePathsIII(int[][] grid) {
        // 初始化起点坐标和总步数,grid[i][j] == 2 也算步数，所以初始化为 1
        int startX = 0, startY = 0, stepNum = 1;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 1){
                    startX = i;
                    startY = j;
                    continue;
                }
                if(grid[i][j] == 0) stepNum++;
            }
        }
        dfs(startX,startY,stepNum,grid);
        return res;
    }
    public void dfs(int startX,int startY,int stepNum,int[][] grid){
        // 边界处理
        if(startX < 0 || startX >= grid.length || startY < 0 || startY >= grid[0].length || grid[startX][startY] == -1) return;
        // 结束条件
        if(grid[startX][startY] == 2) {
            if(stepNum == 0)res++;
            return;
        };
        // 将当前位置标记为已经过，不可重复
        grid[startX][startY] = -1;
        // 依次统计上下左右方向走的步数
        dfs(startX,startY-1,stepNum -1,grid);
        dfs(startX,startY+1,stepNum -1,grid);
        dfs(startX-1,startY,stepNum -1,grid);
        dfs(startX+1,startY,stepNum -1,grid);
        // 结束本次遍历后将当前位置还原为可经过路线，以便下次统计
        grid[startX][startY] = 0;
    }
}
```
* [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int l1 = text1.length(),l2 = text2.length();
        int[][] dp = new int[l1+1][l2+1];
        for(int i = 0; i < l1; i++){
            for(int j = 0; j < l2; j++){
                if(text1.charAt(i) == text2.charAt(j)){
                        dp[i+1][j+1] = dp[i][j] + 1;
                    }else{
                        dp[i+1][j+1] = Math.max(dp[i+1][j],dp[i][j+1]);
                    }
            }
        }
        return dp[l1][l2];
    }
}
```
* [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

保存中间值：

```java
class Solution {
    public int climbStairs(int n) {
       if(n<=2) return n;
       int[] sum = new int[n+1];
       sum[1] = 1;
       sum[2] = 2;
       for(int i = 3; i <= n;i++){
           sum[i] = sum[i-1] + sum[i-2];
       }
       return sum[n];
    }
}
```
动态规划：dp方程:f(n) = f(n-1) + f(n-2);
```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        int f1 = 1,f2 = 2,f3 = 0;
        for(int i = 3;i <= n; i++){
            f3= f1 + f2;
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }
}
```
* [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

思路：

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] path = new int[triangle.size() + 1];
        for(int i = triangle.size() -1; i >= 0;--i){
            for(int j = 0; j < triangle.get(i).size();++j){
                path[j] = Math.min(path[j],path[j+1]) + triangle.get(i).get(j);
            }
        }
        return path[0];
    }
}
```
* [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            if(sum > 0){
                sum += nums[i];
            }else{
                sum = nums[i];
            }
            res = Math.max(res,sum);
        }
        return res;
    }
}
```
* [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

思路：当值为负数时，会令最大乘积变为最小乘积或最小乘积变为最大乘积

```java
class Solution {
    public int maxProduct(int[] nums) {
        int proMin = 1 ,proMax = 1 ,max = Integer.MIN_VALUE;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] < 0){
                int temp = proMax;
                proMax = proMin;
                proMin = temp;
            }
            proMin = Math.min(proMin*nums[i],nums[i]);
            proMax = Math.max(proMax*nums[i],nums[i]);
            max = Math.max(max,proMax);
        }
        return max;
    }
}
```
7. 字典树和并查集
1. 字典树的数据结构

字典树，即Trie树，又称单词查找或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

2. 字典树的核心思想

空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

3. 字典树的基本性质

1、结点本身不存完整单词；

2、从根结点到某结点，路径上经过的字符连接起来，为该结点对应的字符串；

3、每个结点的所有子结点路径代表的字符都不相同。

字典树代码模板：

```java
class Trie {
    private boolean isEnd;
    private Trie[] next;
    /** Initialize your data structure here. */
    public Trie() {
        isEnd = false;
        next = new Trie[26];
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        if (word == null || word.length() == 0) return;
        Trie curr = this;
        char[] words = word.toCharArray();
        for (int i = 0;i < words.length;i++) {
            int n = words[i] - 'a';
            if (curr.next[n] == null) curr.next[n] = new Trie();
            curr = curr.next[n];
        }
        curr.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie node = searchPrefix(prefix);
        return node != null;
    }
    private Trie searchPrefix(String word) {
        Trie node = this;
        char[] words = word.toCharArray();
        for (int i = 0;i < words.length;i++) {
            node = node.next[words[i] - 'a'];
            if (node == null) return null;
        }
        return node;
    }
}
```
[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
```java
class Trie {
    private boolean isEnd;
    private Trie[] next;
    /** Initialize your data structure here. */
    public Trie() {
        isEnd = false;
        next = new Trie[26];
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        if(word == null || word.length() == 0) return;
        Trie curr = this;
        char[] words = word.toCharArray();
        for(int i = 0; i < words.length; i++){
            int n = words[i] - 'a';
            if(curr.next[n] == null) curr.next[n] = new Trie();
            curr = curr.next[n];
        }
        curr.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie node = searchPrefix(prefix);
        return node != null;
    }
    private Trie searchPrefix(String word){
        Trie node = this;
        char[] words = word.toCharArray();
        for(int i = 0; i < words.length; i++) {
            node = node.next[words[i] - 'a'];
            if(node == null) return null;
        }
        return node;
    }
}
/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```
[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)
经典题型，使用字典树+dfs，逻辑思维简单易懂

```java
class Solution {
    private static final int[] dx = new int[]{0,0,-1,1};
    private static final int[] dy = new int[]{-1,1,0,0};
    public List<String> findWords(char[][] board, String[] words) {
        if(words.length == 0) return new ArrayList<>();
        // 构建字典树
         Trie root = new Trie();
        for(String word : words){
            root.insert(word);
        }
        // 遍历board + dfs递归 向四周扩撒构建字符串，并在字典树中查找是否存在此字符串
        Set<String> res = new HashSet<>();
        int m = board.length,n = board[0].length;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                dfs(board,root,i,j,"",res);
            }
        }
        return new ArrayList<String>(res);
    }
    public void dfs(char[][] board, Trie root, int i, int j, String currStr, Set res){
        // 递归结束条件,边界处理以及访问过的字符不能再次访问
        if(i < 0 || j < 0 || i == board.length || j == board[0].length || board[i][j] == '@') return;
        // 递归结束条件 2
        char currChar = board[i][j];
        if(root.next[currChar - 'a'] == null) return;
        // 处理当前层
        char temp = currChar;
        board[i][j] = '@';
        // 构建字符串
        currStr += currChar;
        root = root.next[currChar - 'a'];
        if(root.isEnd){
            res.add(currStr);
        }
        // 向上下左右递归下探
        for(int k = 0; k < dx.length; k++){
            dfs(board,root,i + dx[k], j + dy[k],currStr,res);
        }
        // 将字符串置为空字符串
        currStr = "";
        // 恢复当前层字符
        board[i][j] = temp;
    }
    class Trie {
    private boolean isEnd;
    private Trie[] next;
    /** Initialize your data structure here. */
    public Trie() {
        isEnd = false;
        next = new Trie[26];
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        if(word == null || word.length() == 0) return;
        Trie curr = this;
        char[] words = word.toCharArray();
        for(int i = 0; i < words.length; i++){
            int n = words[i] - 'a';
            if(curr.next[n] == null) curr.next[n] = new Trie();
            curr = curr.next[n];
        }
        curr.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie node = searchPrefix(prefix);
        return node != null;
    }
    private Trie searchPrefix(String word){
        Trie node = this;
        char[] words = word.toCharArray();
        for(int i = 0; i < words.length; i++) {
            node = node.next[words[i] - 'a'];
            if(node == null) return null;
        }
        return node;
    }
}
}
```
1. 并查集数据结构：跟树有些类似，只不过和树是相反的。在树这个数据结构里面，每个结点会记录它的子结点。在并查集里，每个结点会记录它的父节点；

![图片](https://uploader.shimo.im/f/qg8SH3yyfOwN2Lmx.png!thumbnail?fileGuid=jVD8jjdtYgqcrRHV)

2. 并查集适用场景：组团、配对问题
3. 基本操作
    * makeSet(s)：建立一个新的并查集，其中包含s个单元素集合。
    * unionSet(x,y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。
    * find(x)：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。

[参考链接](https://zhuanlan.zhihu.com/p/93647900/)

代码模板：

```java
class UnionFind {
    private int count = 0;
    private int[] parent;
    public UnionFind(int n) {
        count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    public int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        count--;
    }
}
```
[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)
思路：DFS 深度优先搜索

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        if(isConnected.length == 0) return 0;
        boolean[] statistics = new boolean[isConnected.length];
        int res = 0;
        for(int i = 0; i < isConnected.length; i++){
            if(!statistics[i]){
                dfs(isConnected,statistics,i);
                res++;
            }
        }
        return res;
    }
    public void dfs(int[][] isConnected,boolean[] statistics, int i){
        for(int j = 0; j < isConnected.length; j++){
            if(isConnected[i][j] == 1 && !statistics[j]){
                statistics[j] = true;
                dfs(isConnected,statistics,j);
            }
        }
    }
}
```
思路：BFS 广度优先搜索
```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        if(isConnected.length == 0) return 0;
        boolean[] statistics = new boolean[isConnected.length];
        int res = 0;
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 0; i < isConnected.length; i++){
            if(!statistics[i]){
                queue.offer(i);
                res++;
                while(!queue.isEmpty()){
                    int m = queue.poll();
                    for(int n = 0; n < isConnected.length; n++){
                        if(isConnected[m][n] == 1 && !statistics[n]){
                            queue.offer(n);
                            statistics[n] = true;
                        }
                    }
                }
            }
        }
        return res;
    }
}
```
思路：并查集
```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        if(isConnected.length == 0) return 0;
        // 初始化并查集
        UnionFind union = new UnionFind(isConnected.length);
        // 遍历isConnected中每个关联关系，有相连的城市合并为相同的省份
        for(int i = 0; i < isConnected.length; i++){
            for(int j = 0; j < isConnected.length; j++){
                if(isConnected[i][j] == 1){
                    union.union(i,j);
                }
            }
        }
        return union.count;
    }
    class UnionFind {
        private int count = 0;
        private int[] parent;
        public UnionFind(int n) {
            count = n;
            parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        public int find(int p) {
            while (p != parent[p]) {
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ) return;
            parent[rootP] = rootQ;
            count--;
        }
    }
}
```
[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)
思路：DFS 深度优先搜索算法

```java
class Solution {
    private static int[] dx = new int[]{0,0,-1,1};
    private static int[] dy = new int[]{-1,1,0,0};
    public int numIslands(char[][] grid) {
        if (grid.length == 0) return 0;
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
    public void dfs(char[][] grid, int i, int j){
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') return;
        grid[i][j] = '0';
        for(int k = 0; k < dx.length; k++){
            dfs(grid,i+dx[k],j+dy[k]);
        }
    }
}
```
思路：BFS 广度优先搜索
```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid.length == 0) return 0;
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    bfs(grid, i, j);
                }
            }
        }
        return count;
    }
    public void bfs(char[][] grid, int i,int j){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{i,j});
        while(!queue.isEmpty()){
            int[] curr = queue.poll();
            i = curr[0];
            j = curr[1];
            if(i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == '1'){
                grid[i][j] = '0';
                queue.offer(new int[]{i,j-1});
                queue.offer(new int[]{i,j+1});
                queue.offer(new int[]{i-1,j});
                queue.offer(new int[]{i+1,j});
            }
        }
    }
}
```
思路：并查集
```java
class Solution {
    private int m,n;
    public int numIslands(char[][] grid) {
        if (grid.length == 0) return 0;
        m = grid.length;
        n = grid[0].length;
        UnionFind union = new UnionFind(m*n);
        int spaces = 0;// 空地的数量
        int[][] direction = new int[][]{{1,0},{0,1}};
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '0') {
                    spaces++;
                }else{
                    for(int[] dire : direction){
                        int newx = i + dire[0];
                        int newy = j + dire[1];
                        // 判断边界
                        if(newx < m && newy < n && grid[newx][newy] == '1'){
                            // 合并陆地
                            union.union(getIndex(i,j),getIndex(newx,newy));
                        }
                    }
                }
            }
        }
        return union.getCount() - spaces;
    }
    public int getIndex(int i,int j){
        return i*n + j;
    }
    class UnionFind{
        private int count;
        private int[] parent;
        UnionFind(int n){
            count = n;
            parent = new int[n];
            for(int i = 0; i < n; i++){
                parent[i] = i;
            }
        }
        private int find(int p){
            while(p != parent[p]){
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
        private void union(int p, int q){
            int P = find(p);
            int Q = find(q);
            if(P == Q) return;
            parent[P] = Q;
            count--;
        }
        public int getCount(){
            return count;
        }
    }
}
```
[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)
思路：DFS 深度优先搜索

1、遍历 board ，从边界为‘O’的开始递归，查找相联通的‘O’

2、将与边界相联通的‘O’转换为‘#’，剩余‘O’就是被‘X’包围的

3、再次遍历 board，将‘#’转换为原来的‘O’，将‘O’转换为‘X’

```java
class Solution {
    private static int[] dx = new int[]{0,0,-1,1};
    private static int[] dy = new int[]{-1,1,0,0};
    public void solve(char[][] board) {
        if (board.length == 0) return;
        int m = board.length,n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 首先从边界为‘O’的开始递归下探,将与边界‘O’联通的‘O’都替换为‘#’
                boolean isEdge = i == 0 || j == 0 || i == m-1 || j == n-1;
                if(isEdge && board[i][j] == 'O'){
                    dfs(board,i,j);
                }
            }
        }
        // 将递归后的结果进行转换，‘#’代表和边界联通的，剩余的‘O’代表和边界不连通，需要转换为‘X’
        for (int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(board[i][j] == '#'){
                    board[i][j] = 'O';
                }else if(board[i][j] == 'O'){
                    board[i][j] = 'X';
                }
            }
        }
    }
    public void dfs(char[][] board, int i, int j){
        // 递归结束条件
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] == 'X' || board[i][j] == '#') return;
        board[i][j] = '#';
        // 左右上下，递归下探
        for (int k = 0; k < dx.length; k++){
            dfs(board,i+dx[k],j+dy[k]);
        }
    }
}
```
思路：BFS 广度优先搜索
```java
class Solution {
    private static int[] dx = new int[]{0,0,-1,1};
    private static int[] dy = new int[]{-1,1,0,0};
    public void solve(char[][] board) {
        if (board.length == 0) return;
        int m = board.length,n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 首先从边界为‘O’的开始递归下探,将与边界‘O’联通的‘O’都替换为‘#’
                boolean isEdge = i == 0 || j == 0 || i == m-1 || j == n-1;
                if(isEdge && board[i][j] == 'O'){
                    bfs(board,i,j);
                }
            }
        }
        // 将递归后的结果进行转换，‘#’代表和边界联通的，剩余的‘O’代表和边界不连通，需要转换为‘X’
        for (int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(board[i][j] == '#'){
                    board[i][j] = 'O';
                }else if(board[i][j] == 'O'){
                    board[i][j] = 'X';
                }
            }
        }
    }
    public void bfs(char[][] board, int i,int j){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{i,j});
        while(!queue.isEmpty()){
            int[] curr = queue.poll();
            i = curr[0];
            j = curr[1];
            if(i >= 0 && i < board.length && j >= 0 && j < board[0].length && board[i][j] == 'O'){
                board[i][j] = '#';
                for (int k = 0; k < dx.length; k++){
                    queue.offer(new int[]{i+dx[k],j+dy[k]});
                }
            }
        }
    }
}
```
思路：并查集
1、首先创建一个虚拟结点，将所有在边界上为‘O’的点都联通到虚拟结点上；

2、然后再将非边界上的‘O’按是否与边界元素‘O’相连分组；

3、按分组后的情况，将与边界‘O’相连的即就是与虚拟结点相连的都转换为‘O’，不与边界‘O’相连的说明就是被‘X’包围的，转换为‘X’；

```java
class Solution {
    private int[] dx = new int[]{0,0,-1,1};
    private int[] dy = new int[]{-1,1,0,0};
    private int rows,clos;
    public void solve(char[][] board) {
        rows = board.length;
        if (rows == 0) return;
        clos = board[0].length;
        UnionFind union = new UnionFind(rows*clos+1);
        int dummyNode = rows*clos;
        for (int i = 0; i < rows; i++){
            for(int j = 0; j < clos; j++){
                if (board[i][j] == 'O'){
                    if (i == 0 || j == 0 || i == rows - 1 || j == clos - 1){
                        union.union(getIndex(i,j),dummyNode);
                    }else{
                        for(int k = 0; k < dx.length; k++){
                            int currI = i + dx[k];
                            int currJ = j + dy[k];
                            if (currI >= 0 && currI < rows && currJ >= 0 && currJ < clos && board[currI][currJ] == 'O'){
                                union.union(getIndex(i,j),getIndex(currI,currJ));
                            }
                        }
                    }
                }
            }
        }
        for (int i = 0; i < rows; i++){
            for (int j = 0; j < clos; j++) {
                if (union.find(getIndex(i,j)) == union.find(dummyNode)){
                    board[i][j] = 'O';
                }else {
                    board[i][j] = 'X';
                }
            }
        }
    }
    public int getIndex (int i, int j){
        return i * clos + j;
    }
    class UnionFind{
        private int count;
        private int[] parent;
        UnionFind(int n){
            count = n;
            parent = new int[n];
            for (int i = 0; i < n; i++){
                parent[i] = i;
            }
        }
        private int find(int p){
            while(p != parent[p]){
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            return p;
        }
        private void union(int p, int q){
            int P = find(p);
            int Q = find(q);
            if (p == Q) return;
            parent[P] = Q;
            count--;
        }
    }
}
```
